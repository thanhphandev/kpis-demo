import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';

export interface ReportData {
  title: string;
  subtitle?: string;
  generatedBy: string;
  generatedAt: Date;
  data: any[];
  charts?: ChartData[];
  summary?: SummaryData;
}

export interface ChartData {
  type: 'bar' | 'line' | 'pie';
  title: string;
  data: any[];
  xKey?: string;
  yKey?: string;
}

export interface SummaryData {
  totalKPIs: number;
  completedKPIs: number;
  overallCompletion: number;
  departmentBreakdown: Array<{
    name: string;
    kpis: number;
    completion: number;
  }>;
}

export class ReportGenerator {
  static async generatePDF(reportData: ReportData): Promise<Blob> {
    const doc = new jsPDF();
    let yPosition = 20;

    // Header
    doc.setFontSize(20);
    doc.text(reportData.title, 20, yPosition);
    yPosition += 10;

    if (reportData.subtitle) {
      doc.setFontSize(12);
      doc.text(reportData.subtitle, 20, yPosition);
      yPosition += 10;
    }

    // Meta information
    doc.setFontSize(10);
    doc.text(`Generated by: ${reportData.generatedBy}`, 20, yPosition);
    yPosition += 5;
    doc.text(`Generated at: ${reportData.generatedAt.toLocaleString()}`, 20, yPosition);
    yPosition += 15;

    // Summary section
    if (reportData.summary) {
      doc.setFontSize(14);
      doc.text('Summary', 20, yPosition);
      yPosition += 10;

      doc.setFontSize(10);
      doc.text(`Total KPIs: ${reportData.summary.totalKPIs}`, 20, yPosition);
      yPosition += 5;
      doc.text(`Completed KPIs: ${reportData.summary.completedKPIs}`, 20, yPosition);
      yPosition += 5;
      doc.text(`Overall Completion: ${reportData.summary.overallCompletion}%`, 20, yPosition);
      yPosition += 15;

      // Department breakdown
      if (reportData.summary.departmentBreakdown.length > 0) {
        doc.text('Department Breakdown:', 20, yPosition);
        yPosition += 8;

        reportData.summary.departmentBreakdown.forEach(dept => {
          doc.text(`â€¢ ${dept.name}: ${dept.kpis} KPIs (${dept.completion}% complete)`, 25, yPosition);
          yPosition += 5;
        });
        yPosition += 10;
      }
    }

    // Data table
    if (reportData.data.length > 0) {
      doc.setFontSize(14);
      doc.text('KPI Details', 20, yPosition);
      yPosition += 10;

      // Table headers
      doc.setFontSize(8);
      const headers = ['Title', 'Status', 'Progress', 'Deadline', 'Assigned To'];
      const colWidths = [60, 25, 25, 30, 40];
      let xPosition = 20;

      headers.forEach((header, index) => {
        doc.text(header, xPosition, yPosition);
        xPosition += colWidths[index];
      });
      yPosition += 8;

      // Table data
      reportData.data.forEach(kpi => {
        if (yPosition > 270) {
          doc.addPage();
          yPosition = 20;
        }

        xPosition = 20;
        const rowData = [
          kpi.title.substring(0, 25),
          kpi.status,
          `${Math.round(kpi.completionPercentage || 0)}%`,
          new Date(kpi.deadline).toLocaleDateString(),
          `${kpi.assignedTo?.firstName} ${kpi.assignedTo?.lastName}`.substring(0, 20)
        ];

        rowData.forEach((data, index) => {
          doc.text(data, xPosition, yPosition);
          xPosition += colWidths[index];
        });
        yPosition += 6;
      });
    }

    return doc.output('blob');
  }

  static generateExcel(reportData: ReportData): Blob {
    const workbook = XLSX.utils.book_new();

    // Summary sheet
    if (reportData.summary) {
      const summaryData = [
        ['KPI Report Summary'],
        [''],
        ['Generated by:', reportData.generatedBy],
        ['Generated at:', reportData.generatedAt.toISOString()],
        [''],
        ['Total KPIs:', reportData.summary.totalKPIs],
        ['Completed KPIs:', reportData.summary.completedKPIs],
        ['Overall Completion:', `${reportData.summary.overallCompletion}%`],
        [''],
        ['Department Breakdown:'],
        ['Department', 'KPIs', 'Completion %'],
        ...reportData.summary.departmentBreakdown.map(dept => [
          dept.name,
          dept.kpis,
          `${dept.completion}%`
        ])
      ];

      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
    }

    // KPI data sheet
    if (reportData.data.length > 0) {
      const kpiData = reportData.data.map(kpi => ({
        Title: kpi.title,
        Description: kpi.description || '',
        Status: kpi.status,
        Priority: kpi.priority,
        'Current Value': kpi.currentValue,
        'Target Value': kpi.targetValue,
        Unit: kpi.unit,
        'Completion %': Math.round(kpi.completionPercentage || 0),
        Deadline: new Date(kpi.deadline).toLocaleDateString(),
        'Assigned To': `${kpi.assignedTo?.firstName} ${kpi.assignedTo?.lastName}`,
        Department: kpi.departmentId?.name || '',
        'Created At': new Date(kpi.createdAt).toLocaleDateString()
      }));

      const kpiSheet = XLSX.utils.json_to_sheet(kpiData);
      XLSX.utils.book_append_sheet(workbook, kpiSheet, 'KPI Data');
    }

    // Charts data sheet
    if (reportData.charts && reportData.charts.length > 0) {
      reportData.charts.forEach((chart, index) => {
        const chartSheet = XLSX.utils.json_to_sheet(chart.data);
        XLSX.utils.book_append_sheet(workbook, chartSheet, `Chart ${index + 1}`);
      });
    }

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  }

  static async generateReport(
    type: 'pdf' | 'excel',
    reportData: ReportData
  ): Promise<Blob> {
    switch (type) {
      case 'pdf':
        return this.generatePDF(reportData);
      case 'excel':
        return this.generateExcel(reportData);
      default:
        throw new Error(`Unsupported report type: ${type}`);
    }
  }
}